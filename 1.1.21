competition Competition;

int Brain_precision = 0, Controller1_precision = 0;

float myVariable;

// "when started" hat block
int whenStarted1() {
  Drivetrain.setDriveVelocity(80.0, percent);
  Controller1.rumble("....");
  Brain.Screen.print("Don\'t touch it , it works!");
  Controller1.Screen.print("Don\'t touch it , it works!");
  while (true) {
    bottom_intake.setVelocity(100.0, percent);
    top_intake.setVelocity(100.0, percent);
    if (Controller1.ButtonL2.pressing() || Controller1.ButtonR2.pressing()) {
      top_intake.spin(forward);
      bottom_intake.spin(reverse);
    }
    else {
      if (Controller1.ButtonR1.pressing() || Controller1.ButtonL1.pressing()) {
        top_intake.spin(reverse);
        bottom_intake.spin(forward);
      }
      else {
        bottom_intake.stop();
        top_intake.stop();
      }
    }
  wait(5, msec);
  }
  return 0;
}

// "when driver control" hat block
int ondriver_drivercontrol_0() {
  Drivetrain.setDriveVelocity(80.0, percent);
  Controller1.rumble("....");
  Brain.Screen.print("Don\'t touch it , it works!");
  Controller1.Screen.print("Don\'t touch it , it works!");
  while (true) {
    bottom_intake.setVelocity(100.0, percent);
    top_intake.setVelocity(100.0, percent);
    if (Controller1.ButtonL2.pressing() || Controller1.ButtonR2.pressing()) {
      top_intake.spin(forward);
      bottom_intake.spin(reverse);
    }
    else {
      if (Controller1.ButtonR1.pressing() || Controller1.ButtonL1.pressing()) {
        top_intake.spin(reverse);
        bottom_intake.spin(forward);
      }
      else {
        bottom_intake.stop();
        top_intake.stop();
      }
    }
  wait(5, msec);
  }
  return 0;
}

// "when autonomous" hat block
int onauton_autonomous_0() {
  Controller1.rumble("....");
  Brain.Screen.print("Block Code Gang");
  Controller1.Screen.print("Block Code Gang");
  top_intake.spin(forward);
  bottom_intake.spin(reverse);
  return 0;
}

void VEXcode_driver_task() {
  // Start the driver control tasks....
  vex::task drive0(ondriver_drivercontrol_0);

  task rc_auto_loop_task_Controller1(rc_auto_loop_function_Controller1);
  while(Competition.isDriverControl() && Competition.isEnabled()) {this_thread::sleep_for(10);}
  drive0.stop();
  return;
}

void VEXcode_auton_task() {
  // Start the auton control tasks....
  vex::task auto0(onauton_autonomous_0);
  while(Competition.isAutonomous() && Competition.isEnabled()) {this_thread::sleep_for(10);}
  auto0.stop();
  return;
}



int main() {
  vex::competition::bStopTasksBetweenModes = false;
  Competition.autonomous(VEXcode_auton_task);
  Competition.drivercontrol(VEXcode_driver_task);

  // post event registration

  // wait for rotation sensor to fully initialize
  wait(30, msec);

  whenStarted1();
}
